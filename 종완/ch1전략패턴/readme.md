# 내용 정리

## 문제 상황
1. `Duck`이라는 추상 클래스를 확장하여 여러 서브클래스 (`MallardDuck`, `RedheadDuck`, `ToyDuck`)를 만들었다. 
    - 이 추상 클래스는 여러 서브클래스가 공통적으로 사용하는 `quack(), swim()` 메소드는 추상 클래스에 이미 구현 되어있다.
2. 그런데 오리가 날아다녀야 한다는 요구사항을 받았다. 그래서 오리가 날게 만들기 위하여 추상 클래스인 `Duck`에 `fly()`를 추가하였다
3. 늘 그렇듯 버그가 생겼는데, 원래 날아서는 안되는 `ToyDuck`이라는 서브 클래스도 같이 날 수 있게 된 것이다.
4. 게다가 비즈니스 상황에 의해 이 `Duck`이라는 클래스의 변경이 잦아질 예정이다.

## 순진한 해결 방안
- 추상클래스 `Duck`의 변경이 자주 일어날 것으로 예상되므로 `Duck`의 행동들을 일일히 인터페이스로 뺀다. 예를 들면 `fly()`에 대해서 `Flyable`이러는 인터페이스로 뺀다.
### 예상 문제점
- 코드 중복: `Flyable`이라는 메소드 하나를 구현하기 위해 모든 서브클래스들은 기존의 `Duck`에 있던 `fly()`를 복붙해야한다. `fly()`라는 공통 메소드를 수정한다 하면 수십개의 서브클래스를 일일히 수정해야하는 대참사가 벌어질 것이다.

## 디자인 원칙
### (매우중요) 달라지는 부분과 달라지지 않는 부분을 분리한다.
1. 자주 바뀌는 부분과 바뀌지 않는 부분을 인식한다.
2. 그리고 바뀌지 않는 부분은 캡슐화한다. 
3. 이러면 바뀌지 않는 부분에 대한 영향을 없애고, 자유로이 고치거나 확장할 수 있다.
### 구현체이 아닌 인터페이스에 맞춰 프로그래밍한다 (DI)
- 인터페이스를 통해 호출하는 방식이 훨씬 변경에 유연하다. 인터페이스가 규격을 제공하기 때문
### 상속보다는 구성을 활용한다.
- `FlyBehavior`는 `FlyWithWings`가 될 수도 있고 `NoFlying`이 될 수 있다. 기존의 상속 방식에서는 `fly()`를 오버라이드를 하여 '행동을 수정'했다면, 구성의 방식에서는 `FlyBehavior`를 구현한 클래스 중에서 다른 것으로 '행동을 교체'하면 끝이다.
- 개발에 할애하는 시간보다 유지보수에 할애하는 시간이 훨씬 길기 때문에, 개발을 빠르게 해주는 상속 방식보다 유지보수를 편리하게 해주는 구성 방식이 더 유리하다.

### 적용하기
1. `Duck`에서 바뀌지 않는 부분을 찾는다: `swim()`
2. `Duck`에서 바뀌는 부분을 분리한다: `fly(), quack(), display()`
3. 바뀌는 부분에 대한 '행동' 인터페이스를 만든다: `fly()`를 `FlyBehavior`로 
4. 구체적인 행동은 별도의 클래스로 구현한다, 그리고 이 클래스는 위의 행동 인터페이스를 구현하는 형태이다: `FlyWithWings implements FlyBehavior`, `NoFlying implements FlyBehavior`
5. 멤버 변수에 행동 인터페이스를 추가하고 해당 행동을 구현한 클래스를 참조하도록 한다.
    `FlyBehavior flyBehavior = new FlyWithWings();`

# 어디에 적용하면 좋을까?
- 스프링에서 이미 일상적으로 사용하고 있다, 바로 의존성 주입(Dependency Injection). <br>구현 클래스는 알 필요 없이, 그 클래스가 서비스 인터페이스를 구현했다는 사실 하나만으로 손쉽게 서비스 구현체를 교체할 수 있다.
- 테스트: 목업 오브젝트가 필요할 때. 즉, 메소드의 구체적인 로직은 필요 없고, 메소드가 리턴하는 값만 필요한 경우 유용할것이다.
